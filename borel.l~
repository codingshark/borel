%{
#include <string>
#include <iostream>
#include <list>
#include "borel.tab.h"

using std::string;
using std::list;
using std::cout;
using std::endl;

extern "C" int yywrap();

list<string> str_stack;

string usr_str;

int anguler_bracket_num;
int is_non_printable_str;
%}

%x COMMENT

%x USR_CODE
%x USR_STR
%x USR_TYPE

%%

<<EOF>>    {return 0;}
(" "|\t)+    //keep silent

":"	|
"|"	|
";"			{return yytext[0];}

"%token"		{return TOKEN;}
"%type"			{return TYPE;}

"//"			{BEGIN COMMENT;}
<COMMENT>\n		{BEGIN INITIAL;}
<COMMENT>.*		/*keep silent*/

"/*"			{BEGIN CPP_COMMENT;}
<CPP_COMMENT>"*/"	{BEGIN INITIAL;}
<CPP_COMMENT>[.\n]*		/*keep silence*/

"<"			{	BEGIN USR_TYPE; 
				usr_str = ""; 
				anguler_bracket_num = 1;
				is_non_printable_str = 1;
			}
			
<USR_TYPE>"<"		{	anguler_bracket_num++;
				is_non_printable_str = 0;
				usr_str += "<";
				if(anguler_bracket_num == 0)
				{	
					cout<<"***error lexical error:\t"<<usr_str<<endl;
					BEGIN INITIAL;
				}
			}
<USR_TYPE>">"		{	anguler_bracket_num--;
				if(anguler_bracket_num != 0)
				{
					usr_str += ">";
					is_non_printable_str = 0;
				}else
				{
					if(is_non_printable_str == 1)
					{// the string is [\a\b\t\n\v\f\r]+
						str_stack.push_back("");
					}
					else
					{
						str_stack.push_back(usr_str);
					}
					BEGIN INITIAL;
				}
				return USR_TYPE_Y;
			}
<USR_TYPE>[\a\b\t\n\v\f\r ]+	{usr_str += yytext;}
<USR_TYPE>[^<>\a\b\t\n\v\f\r ]+	{usr_str += yytext; is_non_printable_str = 0;}

\"			{BEGIN USR_STR; usr_str = "";}
<USR_STR>\\\"		{usr_str += "\\\"";}
<USR_STR>\\		{usr_str += "\\";}
<USR_STR>[^\"\\]+	{usr_str += yytext;}
<USR_STR>\"		{BEGIN INITIAL; str_stack.push_back(usr_str); return USR_STR_Y;}

[A-Za-z0-9_]*		{str_stack.push_back(yytext); return IDENTIFIER;}

"%%"			//lexical sugar

"\n"
.			{cout<<"***error lexical error:\t"<<yytext<<endl;}
%%

int yywrap()
{
    return 1;
}
