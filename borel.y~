%{

#include <stdio.h>
#include <string>
#include <iostream>
#include <list>
#include "parser.h"
#include "grammar.h"
#include "backend.h"

using std::string;
using std::list;
using std::cout;
using std::endl;

#ifdef YYLEX_PARAM
int yylex (YYLEX_PARAM);
#else
int yylex ();
#endif

#define DEBUG_PARSER

#ifdef DEBUG_PARSER
#define PRINT(str)	cout<<str<<endl
#else
#define PRINT(str)
#endif

extern "C" int yyerror(const string & s);

extern FILE * yyin;

extern list<string> str_stack;

grammar		cfg;
parser		a_parser(cfg, str_stack);
	
%}

%union
{
	int stub;
}

%token <stub> USR_TYPE_Y
%token <stub> USR_STR_Y
%token <stub> IDENTIFIER
%token <stub> TOKEN
%token <stub> TYPE

%type <stub> grammar

%type <stub> type_list
%type <stub> type

%type <stub> node_list
%type <stub> node
%type <stub> branches
%type <stub> rules


%left '|'

%%

grammar	:
	type_list node_list	{PRINT("GRAMMAR:NODE_LIST TYPE_LIST"); a_parser.on_grammar();}
|	node_list type_list	{PRINT("SYNTAX ERROR"); a_parser.on_grammar_reversed();}
|	type_list		{PRINT("SYNTAX ERROR"); a_parser.on_grammar_missing_nodes();}
|	node_list		{PRINT("SYNTAX ERROR"); a_parser.on_grammar_missing_types();}
	;

type_list:
	type_list type		{PRINT("TYPE_LIST:TYPE_LIST TYPE"); a_parser.on_type_list();}
|	type			{PRINT("TYPE_LIST:TYPE"); a_parser.on_type_list();}
	;
	
type	:
	TOKEN USR_TYPE_Y IDENTIFIER	{PRINT("TYPE:TOCKEN"); a_parser.on_token();}
|	TYPE USR_TYPE_Y IDENTIFIER	{PRINT("TYPE:TYPE"); a_parser.on_type();}
	;

node_list:
	node_list node		{PRINT("NODE_LIST:LIST NODE"); a_parser.on_node_list();}
|	node			{PRINT("NODE_LIST:NODE"); a_parser.on_node_list();}
	;

node	:
	IDENTIFIER ':' branches ';'		{PRINT("NODE"); a_parser.on_node();}
	//redesign the following three syntactic error patterns
|	IDENTIFIER ':' branches			{//cause shift/reduce conflicts, but works fine
							PRINT("SYNTAX ERROR");
							a_parser.on_node_missing_semicolon();
						}
|	IDENTIFIER branches ';'			{//cause shift/reduce conflicts, but works fine
							PRINT("SYNTAX ERROR");
							a_parser.on_node_missing_colon();
						}
|	IDENTIFIER branches			{//cause shift/reduce conflicts, but works fine
							PRINT("SYNTAX ERROR");
							a_parser.on_node_missing_colon_semicolon();
						}
	;

branches:
	branches '|' branches	{PRINT("BRANCHES:BRANCHES BRANCHES");}
|	rules			{PRINT("BRANCHES:RULES"); a_parser.on_branches();}
|				{PRINT("BRANCHES:EMPTY"); a_parser.on_branches_empty();}
	;

rules	:
	rules IDENTIFIER	{PRINT("RULES:RULES ID"); a_parser.on_rules_id();}
|	rules USR_STR_Y		{PRINT("RULES:RULES STR"); a_parser.on_rules_str();}
|	IDENTIFIER		{PRINT("RULES:ID"); a_parser.on_rules_id();}
|	USR_STR_Y		{PRINT("RULES:STR"); a_parser.on_rules_str();}
	;

%%

int yyerror(const string & s)
{
    cout<<s<<", near \""<<str_stack.back()<<"\""<<endl;
    return 1;
}

main(int argc, char ** argv)
{
	if(argc != 2)
	{
		cout<<argv[0]<<" grammar file"<<endl;
		return 0;
	}

	FILE *f = fopen(argv[1], "r");
	if(!f) {
		cout<<"\t*** ERROR:cannot open grammar file!"<<endl;
		return 0;
	}
	yyin = f;
	yyparse();

	backend		bknd(cfg);
	bknd.generate_output();

	cout<<"finish parsing"<<endl;
	fclose(f);

	return 0;

}
